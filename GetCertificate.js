/**
 * TLS Dashboard by Craine Runton
 * Source: https://github.com/cmrunton/tls-dashboard
 *
 * See /LICENSE for licensing details
 */

var https = require('https');

/**
 * Creates a connection to the host, and then reads the resulting peer certificate to extract the desired info
 *
 * @param {string} host The
 * @param {int} index
 * @param {array} array The
 */
function CertificateSnoofer(host, port = 443, timeOut = 500) {

    return new Promise((resolve, reject) => {

        let options = {
            hostname: host,
            port: port,
            method: 'GET',
            timeout: timeOut,
            agent: false,
            rejectUnauthorized: false,
            ciphers: 'ALL'
        }

        handleRequest(options)
            .then(cert => resolve(cert))
            .catch(err => {
                console.log(err);
            })

    })

};

function handleRequest(option) {

    return new Promise((resolve, reject) => {

        var req = https.request(option, function (res) {

            let cert = res.connection.getPeerCertificate();
            let parsed = {
                'server': option.hostname,
                'subject': {
                    'org': cert.subject.O,
                    'common_name': cert.subject.CN,
                    'sans': cert.subjectaltname
                },
                'issuer': {
                    'org': cert.issuer.O,
                    'common_name': cert.issuer.CN
                },
                'info': {
                    'valid_from': new Date(Date.parse(cert.valid_from)),
                    'valid_to': new Date(Date.parse(cert.valid_to))
                }
            };

            resolve(parsed);

        });

        req.on('timeout', function () {
            req.abort();
        });

        // Handle errors generated by failed requests
        req.on('error', function (e) {

            var parsed = {
                'server': option.hostname,
                'errorCode': '',
                'description': ''
            };

            if (e.hasOwnProperty('code')) {
                switch (e.code) {
                    case 'CERT_HAS_EXPIRED':
                        parsed.description = 'The certificate has expired';
                        parsed.errorCode = e.code;
                        break;
                    case 'ECONNRESET':
                        parsed.description = 'The connection was reset by the server or timed out';
                        parsed.errorCode = e.code;
                        break;
                    case 'ECONNREFUSED':
                        parsed.description = 'The connection was refused by the remote server';
                        parsed.errorCode = e.code;
                        break;
                    case 'UNABLE_TO_VERIFY_LEAF_SIGNATURE':
                        parsed.description = 'The server provided a self-signed certificate or the provided certificate chain was incomplete';
                        parsed.errorCode = e.code;
                        break;
                    default:
                        parsed.description = 'An unspecified error occured';
                        parsed.errorCode = e.code;
                        break;
                };

            } else if (e.hasOwnProperty('reason')) {

                switch (e.reason) {
                    default:
                        parsed.description = 'There was mismatch between the requested hostname and the certificate presented by the server';
                        parsed.errorCode = 'HOSTNAME_MISMATCH';
                        break;
                }

            }

            resolve(parsed);

        })

        // End the request
        req.end();

    })

}

module.exports = CertificateSnoofer